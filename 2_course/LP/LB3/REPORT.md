#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Мохляков П.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |         4     |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Метод поиска в простанстве состояний удобным образом подходит для задач, в которых дискретное число состояний системы, заданы условия начального и конечного состояния и условия перехода из одного состояния в другое. Таким образом эти задачи удобно решаются всеми тремя типами поиска: поиск в глубину, поиск в ширину и итератиный поиск. Для всех этих видов поиска оказывается очень удобным язык Prolog. В нем мы можем легко задать состояние системы и интуитивно определить её правила перехода в другое состояние. За счет удобного перебора и бэктрекинга Prolog пректрасно подходит для этого типа задач.

## Задание

Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.При этом черные шары можно передвигать только вправо, а белые - только влево. 

## Принцип решения

Для начала опишем предикат перехода из одного состояния в другое. В предикате пишем замены для белого и черного шара с пустым местом в списке, которые хранит состояние.

```prolog
move_w([0,w|L],[w,0|L]).
move_w([0,X,w|L],[w,X,0|L]).
move_w([X|L1],[X|L2]):-move_w(L1,L2).


move_b([b,0|L],[0,b|L]).
move_b([b,X,0|L],[0,X,b|L]).
move_b([X|L1],[X|L2]):-move_b(L1,L2).

move(S,N):-move_w(S,N).
move(S,N):-move_b(S,N).
move(S,S).
```

Для удобства все пути в дальнейшем будут выведены с использованием предиката write_path, что упрощаем чтение вывода. При необходимости его можно легко убрать.
```prolog
write_path([]):-write("-------------\n").
write_path([X|L]):-write(X),write("\n"),write_path(L).
```
Далее мы описываем три вида поиска. Для начала напишем поиск в глубину. Он основан на том, что если мы уже находимся в нужном состоянии, то ничего делать не нужно, и можно вернуть путь, который является списком состояний через который мы прошли. В случае если мы не в конечном состоянии мы делаем следующий "шаг", смотрим, чтобы полученного состояния не было в списке пройденных, чтобы избежать зациклеваний, и ищем уже путь от полученного состояния до конечного, тем самым вызвав рекурсию.

```prolog
path(Start,Finish):-path(Start,Finish,[Start],Path),reverse(Path,R),write_path(R).
path(Start,Start,Path,Path).
path(Start,Finish,List,Path):-move(Start,Z),not(member(Z, List)),path(Z,Finish,[Z|List],Path).
```

Поиск в ширину. Для начала стоит описать придекат добавление в список пройденных состояний нового состояния. Он добавляем в список пройденных состояние состояние, которого мы можем достичь из последнего до этого и которое еще не встречалось.
```prolog
prolong([H|T],[X,H|T]):-move(H,X),not(member(X,[H|T])).
```
В поиске в ширину мы храним все возможные варианты развития в списоке списков состояния. Конечным является тот список первый элимент которого является искомым состоянием. Иначе мы находи все возможные пути развития этого списка состояний и добавляем его в конец списка списков, удаляя при этом элимент на основе которого строились дополнительные пути.
```prolog
path_min(X,Y):-bdth([[X]],Y,P),reverse(P,R),write_path(R).
bdth([[X|T]|_],X,[X|T]).
bdth([P|QI],X,R):-findall(Z,prolong(P,Z),T),append(QI,T,QO),!,bdth(QO,X,R).
```
Итерационный поиск использует генератор целых положительных чисел. Мы можем описать два типа таких предикатов. Первый будет бесконечно генерировать эти числа, второй пока они меньше определенного числа, я буду использовать второй, так как если использовать предикат без ограничений он будет пытаться перебрать действия даже после нахождения всех ответов. Предикат я ограничу максимально 30 ходами, так как мне уже известно, что все варианты ответа имеют меньшее количество состояний.
```prolog
iter(1).
iter(M):-iter(N),M is N + 1.

iter_2(X,M):-iter_2(X,1,M).
iter_2(X,Y,M):-Y<M,X is Y.
iter_2(X,Y,M):-Y<M,Y1 is Y+1,iter_2(X,Y1,M).
```

Алгоритм похож на комбинацию первых двух так как он с одной стороны рекурсивен и опускается вглубь, с другой стороны он находит варианты ответа от меньшего к большему. Это тот алгоритм является практически копией поиска в глубину, за исключением дополнительных ограничений на количество "шагов". Положительным результатом поиска является совпадение начала списка пройденых состояний и конечного состояния, при этом оставшиеся количество шагов равно нулю. Если оставшихся шагов будет больше нуля, то такой ответ не учитывается. При самом поиске решений, мы проверяем, что количество оствашихся шагов больше нуля, и если это так то мы продливаем пройденный путь, предикатом описанным выше, уменьшаем количество оставшихся шагов и пытаемся найти путь из следующего состояния.

```prolog
search_id(Start,Finish):-iter_2(Level,30),search_id([Start],Finish,Path,Level),reverse(Path,P),write_path(P).
search_id([Finish|T],Finish,[Finish|T],0).
search_id(Path,Finish,R,N):-N>0,prolong(Path,NewPath),N1 is N - 1,search_id(NewPath,Finish,R,N1).
```

## Результаты

Приведите результаты работы программы: найденные пути, время, затраченное на поиск тем или иным алгоритмом, длину найденного первым пути. Используйте таблицы,
если необходимо.

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы   |
|-----------------|--------------------------------|-----------------|
| В глубину       |                20              |      1-2        |
| В ширину        |                20              |      2-3        |
| ID              |                20              |     9-11        |

## Выводы
Эта лабораторная работа научила меня методам поиска в пространстве состояний. И заставила задуматься над релизации этих алгоритмов на импертивных языках, полноценная реализация в которых менее удобна чем в Prolog.

Данная лабораторная работа показала, что при поиске всех вариантов без зациклеваний лучше всего подходит поиск в глубину. Для поиска кратцайшего пути, или путей с зацикливаниями, если отсутствует дефицит памяти мы можем использовать поиск в ширину, так как он почти не уступает по времени поиска от поиска в глубину. Если же место в памяти ограничено, то можно искать итерационно, но при этом мы теряем во времени.






